-- Wrapper for AddUniqueCall that checks for time_global update before executing function
local function throttle(func, tg_throttle)
    local tg = 0
    if not tg_throttle or tg_throttle == 0 then
        return function(...)
            local t = time_global()
            if t ~= tg then
                tg = t
                return func(...)
            end
        end
    elseif type(tg_throttle) == "function" then
        return function(...)
            -- If true - fire immediately
            if tg_throttle(tg) == true then
                return func(...)
            end

            -- If false/nil - don't fire
            if not tg_throttle(tg) then
                return
            end

            -- If number - throttle by that number
            local t = time_global()
            if t < tg then return end
            tg = t + tg_throttle(tg)
            return func(...)
        end
    else
        return function(...)
            local t = time_global()
            if t < tg then return end
            tg = t + tg_throttle
            return func(...)
        end
    end
end

local function get_random_array_element(t)
    return t[math.random(#t)]
end

local function get_time_elapsed()
    --trace(time_factor)
    return math.floor(game.get_game_time():diffSec(level.get_start_time()) / level.get_time_factor() * 10) * 0.1
end

local function play_sound_on_actor(snd, volume, frequency, looped)
    if not snd then
        trace("snd is nil")
        return
    end
    local actor = db.actor
    local snd = xr_sound.get_safe_sound_object(snd)
    if snd then
        snd:play(actor, 0, looped and (sound_object.s2d + sound_object.looped) or sound_object.s2d)
        snd.volume = volume or 1
        snd.frequency = frequency or 1
        return snd
    end
end

function bind(obj)
    obj:bind_object(af_cell_grenade_binder(obj))
end

class "af_cell_grenade_binder" (object_binder)

function af_cell_grenade_binder:__init(obj) super(obj)
    self.sec = self.object:section()

    -- Geometry ray instance
    self.contact_range = 1.1
    self.create_collision_ray = function()
        return demonized_geometry_ray.geometry_ray({
            ray_range = 1000,
            contact_range = self.contact_range,
            flags = 2,
            ignore_object = self.object,
            visualize = false,
        })
    end
    self.ray = self.create_collision_ray()

    -- Update time and period
    self.tg = 0
    self.tg_period = 33
    self.tg_time = 0

    -- Above this velocity cocktail will blow up
    self.velocity_threshold = 0

    -- After this distance cocktail will blow up
    self.travel_distance_threshold = 0

    -- After this time cocktail will blow up
    self.destroy_time = 3000

    -- Flag to force destroy
    self.force_destroy = false

    -- Flag of already destroyed
    self.destroyed = false

    -- Flag of fused
    self.fused = false

    -- Fastcall to collision detection check
    self.object:set_fastcall(self.fastcall, self)
end

function af_cell_grenade_binder:fastcall()
    local obj = self.object
    local id = obj:id()

    -- If object is in someone hands, dont check it
    if obj:parent() then
        if self.position then
            self.velocity = nil
            self.position = nil
            self.direction = nil
            self.travel_distance = nil
            self.tg = 0
            self.tg_time = 0
            self.fused = nil
        end
        return
    end

    -- Set initial position
    if not self.position then
        self.velocity = 0
        self.position = obj:position()
        self.direction = vector():set(0, -1, 0)
        self.travel_distance = 0
        self.tg = 0
        self.tg_time = 0
        return
    end

    -- Throttle updates
    self.tg = self.tg + device().time_delta

     -- Explode molotov if destroy time is near
    if self.fused and self.tg + device().time_delta * 4 > self.destroy_time then
        self:explode()
        return
    end

    if self.tg < self.tg_time then
        return
    end
    self.tg_time = self.tg + self.tg_period

    if self.fused == nil then
        self.fused = not alife_object(obj:id())
    end

    -- if force_destroy is true, the object will be destroyed
    -- Use destroy_object, thats what engine uses for bolts
    if self.force_destroy and not self.destroyed then
        self:explode()
        return
    end

    -- Calculate velocity, direction, position and travel distance
    -- Direction is (vectors) new position - old position
    -- Velocity is (scalar) length of direction vector
    local pos = obj:position()
    local dir = vector():set(pos):sub(self.position)
    self.velocity = dir:magnitude()
    self.direction = dir:normalize()
    self.position = pos
    self.travel_distance = self.travel_distance + self.velocity

    local velocity = self.velocity

    -- Offset a bit position of ray to shoot
    local ray_pos = vector():set(self.position):mad(self.direction, -0.1)
    
    -- Shoot ray
    self.ray = self.create_collision_ray()
    local res = self.ray:get(ray_pos, self.direction)

    -- Check for material (engine edit required)
    local not_passable = true
    local result = res.result

    if  result
    and result.material_name
    and result.material_shoot_factor
    then
        local name = result.material_name
        local shoot_factor = result.material_shoot_factor

        if false 
        or string.find(name, "bush") 
        or string.find(name, "water")
        -- or self.ray:isMaterialFlag("flShootable") and shoot_factor <= 0.01
        -- or (self.ray:isMaterialFlag("flBounceable") and not self.ray:isMaterialFlag("flPassable"))
        then
            not_passable = false
        end
    end

    -- Debug
    -- print_tip("ray shot from %s, velocity %s, dist %s, in_contact %s, tg %s, tg_time %s", self:get_name(), self.velocity, res.distance, res.in_contact, self.tg, self.tg_time)

    -- If ray in contact range and enough velocity and enough distance traveled - blow up
    -- Set flag to destroy so it postpones on next update
    if res.in_contact and not_passable
    then
        -- print_tip("obj %s is in_contact %s, velocity %s", self.object:name(), res.in_contact, velocity)
        self.force_destroy = true
    end
end

function af_cell_grenade_binder:explode()
    self.destroyed = true
    CellProtectionField({position = self.object:position()})
    self.object:destroy_object()
end

local CellProtectionFieldActiveActors = {[AC_ID] = {}}
local CellProtectionFieldRegistry = {}
class "CellProtectionField"
function CellProtectionField:__init(args)
    self.time_created = get_time_elapsed()
    CellProtectionFieldRegistry[self] = self

    -- Params
    self.position = args.position
    self.time_active = args.time_active or 60
    self.radius = args.radius or 6
    self.radius_sqr = self.radius ^ 2
    
    if args.particles and type(args.particles) ~= "table" then
        args.particles = {args.particles}
    end
    self.particles = args.particles or {[[perk_based_artefacts\anomaly2\anomaly_teleport]]}
    self.particle_objects = {}
    for _, v in ipairs(self.particles) do
        local o = particles_object(v)
        local e = throttle(function()
            if not o:playing() then
                o:play_at_pos(self.position)
            end
        end)
        AddUniqueCall(e)
        table.insert(self.particle_objects, {
            object = o,
            event = e
        })
    end

    if args.sounds and type(args.sounds) ~= "table" then
        args.sounds = {args.sounds}
    end
    self.sounds = args.sounds or {[[perk_based_artefacts\BFGIDLE]]}
    self.sound_objects = {}
    for _, v in ipairs(self.sounds) do
        local o = sound_object(v)
        o:play_at_pos(nil, self.position, 0, sound_object.s3d + sound_object.looped)
        table.insert(self.sound_objects, o)
    end
    
    self.delete_all_actors = function()
        for id, binders in pairs(CellProtectionFieldActiveActors) do
            binders[self] = nil
        end
    end

    self.protection_field_iterate_func = function(obj)
        if obj:id() ~= AC_ID and (IsMonster(obj) or IsStalker(obj)) and obj:alive() and obj:position():distance_to_sqr(self.position) <= self.radius_sqr then
            CellProtectionFieldActiveActors[obj:id()] = CellProtectionFieldActiveActors[obj:id()] or {}
            CellProtectionFieldActiveActors[obj:id()][self] = true
        end
    end

    self.iterate_update = throttle(function()
        self.delete_all_actors()
        if db.actor:position():distance_to_sqr(self.position) <= self.radius_sqr then
            CellProtectionFieldActiveActors[AC_ID][self] = true
        end

        -- Enable for making it for active for everyone
        -- level.iterate_nearest(self.position, self.radius, self.protection_field_iterate_func)
    end, 800)

    self.update = throttle(function()
        local time_elapsed = get_time_elapsed()
        if time_elapsed > self.time_created + self.time_active then
            self.destroy()
            return true
        end
    end)

    self.destroy = function()
        self.delete_all_actors()
        for k, v in pairs(self.particle_objects) do
            v.object:stop()
            RemoveUniqueCall(v.event)
        end
        for k, v in pairs(self.sound_objects) do
            v:stop()
        end
        CellProtectionFieldRegistry[self] = nil
        RemoveUniqueCall(self.update)
        RemoveUniqueCall(self.iterate_update)
        -- collectgarbage("collect")
    end

    AddUniqueCall(self.update)
    AddUniqueCall(self.iterate_update)
end

function CellProtectionField:__finalize()
    -- printf("CellProtectionField destroyed")
end

function on_before_hit(npc, s_hit, bone_id, flags)
    if not perk_based_artefacts.artefact_props.af_cell.valid_hits[s_hit.type] then
        return
    end

    if is_empty(CellProtectionFieldActiveActors[npc:id()]) then
        return
    end

    local p = s_hit.power
    s_hit.power = s_hit.power * random_float(0, 0.4)
    local power = p - s_hit.power

    if npc:id() == AC_ID then
        local rad_amount = power * 0.02
        db.actor:change_radiation(rad_amount)

        local function rad_sound()
            play_sound_on_actor("detectors\\geiger_" .. math.random(8), 1)
            return true
        end
        for i = 1, 5 do
            CreateTimeEvent(time_global() .. "af_cell" .. i, "af_cell" .. i, random_float(0.15, 0.3) * i, rad_sound)
        end

        play_sound_on_actor("anomaly\\electra_hit" .. get_random_array_element({"", "1"}), 1, 0.5)
    end
end

function actor_on_before_hit(shit, bone_id, flags)
    on_before_hit(db.actor, shit, bone_id, flags)
end

function save_state(m_data)
    m_data.pba_CellProtectionFieldRegistry = empty_table(m_data.pba_CellProtectionFieldRegistry)
    for k, v in pairs(CellProtectionFieldRegistry) do
        local props = {
            particles = k.particles,
            position = utils_data.vector_to_string(k.position),
            radius = k.radius,
            sounds = k.sounds,
            time_active = k.time_active,
            time_created = k.time_created,
        }
        -- print_r(props)
        table.insert(m_data.pba_CellProtectionFieldRegistry, props)
    end
end

function load_state()
    local m_data = alife_storage_manager.get_state()
    if m_data.pba_CellProtectionFieldRegistry then
        for _, v in ipairs(m_data.pba_CellProtectionFieldRegistry) do
            -- print_r(v)
            local c = CellProtectionField({
                particles = v.particles,
                position = utils_data.string_to_vector(v.position),
                radius = v.radius,
                sounds = v.sounds,
                time_active = v.time_active,
            })
            c.time_created = v.time_created
        end
    end
end

function on_game_start()
    RegisterScriptCallback("actor_on_before_hit", actor_on_before_hit)
    RegisterScriptCallback("npc_on_before_hit", on_before_hit)
    RegisterScriptCallback("monster_on_before_hit", on_before_hit)
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("actor_on_first_update", load_state)
end
