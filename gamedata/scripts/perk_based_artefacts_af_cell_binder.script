function bind(obj)
    obj:bind_object(af_cell_grenade_binder(obj))
end

class "af_cell_grenade_binder" (object_binder)

function af_cell_grenade_binder:__init(obj) super(obj)
    self.sec = self.object:section()

    -- Geometry ray instance
    self.contact_range = SYS_GetParam(2, self.sec, "contact_range", 1)
    self.create_collision_ray = function()
        return demonized_geometry_ray.geometry_ray({
            ray_range = 1000,
            contact_range = self.contact_range,
            flags = 2,
            ignore_object = self.object,
            visualize = false,
        })
    end
    self.ray = self.create_collision_ray()

    -- Update time and period
    self.tg = 0
    self.tg_period = 33
    self.tg_time = 0

    -- Above this velocity cocktail will blow up
    self.velocity_threshold = 0

    -- After this distance cocktail will blow up
    self.travel_distance_threshold = 0

    -- After this time cocktail will blow up
    self.destroy_time = 5000

    -- Flag for can be shot
    self.can_be_shot = false

    -- Flag to allow panic for npcs
    self.can_panic_npc = false

    -- Flag to enable velocity check depending on a surface the molotov is flying to
    -- Allows to simulate bouncing behaviour if projected speed to surface is low
    self.advanced_velocity_check = SYS_GetParam(1, self.sec, "advanced_velocity_check")

    -- Flag to force destroy
    self.force_destroy = false

    -- Flag of already destroyed
    self.destroyed = false

    -- Damage params
    self.hit_type                   = hit[SYS_GetParam(0, self.sec, "AOE_hit_type", "burn")] or hit["burn"]
    self.damage                     = SYS_GetParam(2, self.sec, "AOE_damage", 0)
    self.damage_drop                = SYS_GetParam(2, self.sec, "AOE_damage_drop", 0)
    self.damage_period              = SYS_GetParam(2, self.sec, "AOE_damage_period", 200)

    self.explosion_damage           = SYS_GetParam(2, self.sec, "AOE_explosion_damage", 0)
    self.explosion_damage_drop      = SYS_GetParam(2, self.sec, "AOE_explosion_damage_drop", 0)
    self.explosion_damage_type      = hit[SYS_GetParam(0, self.sec, "AOE_explosion_damage_type", "")] or self.hit_type
    self.explosion_radius           = SYS_GetParam(2, self.sec, "AOE_explosion_radius", 0)
    self.explosion_volumetric       = SYS_GetParam(1, self.sec, "AOE_explosion_volumetric")
    self.explosion_sound            = SYS_GetParam(0, self.sec, "AOE_explosion_sound", "")
    self.explosion_particles        = SYS_GetParam(0, self.sec, "AOE_explosion_particles") and string.len(SYS_GetParam(0, self.sec, "AOE_explosion_particles")) > 0 and SYS_GetParam(0, self.sec, "AOE_explosion_particles") ~= "" and SYS_GetParam(0, self.sec, "AOE_explosion_particles")
    self.explosion_particles_offset = str_explode(SYS_GetParam(0, self.sec, "AOE_explosion_particles_offset", ""), ",")
    if string.len(self.explosion_particles_offset[1]) == 0 then
        self.explosion_particles_offset = nil
    else
        self.explosion_particles_offset[1] = self.explosion_particles_offset[1] and tonumber(self.explosion_particles_offset[1]) or 0
        self.explosion_particles_offset[2] = self.explosion_particles_offset[2] and tonumber(self.explosion_particles_offset[2]) or 0
        self.explosion_particles_offset[3] = self.explosion_particles_offset[3] and tonumber(self.explosion_particles_offset[3]) or 0
    end

    self.volumetric               = SYS_GetParam(1, self.sec, "AOE_volumetric")
    self.ignore_actor             = SYS_GetParam(1, self.sec, "AOE_ignore_actor")
    self.lifetime                 = SYS_GetParam(2, self.sec, "AOE_lifetime", 0)
    self.lifetime_damage_drop     = SYS_GetParam(2, self.sec, "AOE_lifetime_damage_drop", 0)
    self.dot_damage_time          = SYS_GetParam(2, self.sec, "AOE_dot_damage_time", 0)
    self.radius                   = SYS_GetParam(2, self.sec, "AOE_radius", 0)
    self.aoe_vanilla_actor_damage = SYS_GetParam(1, self.sec, "AOE_aoe_vanilla_actor_damage")
    self.aoe_sound                = SYS_GetParam(0, self.sec, "AOE_aoe_sound", "")
    self.aoe_hit_sound            = SYS_GetParam(0, self.sec, "AOE_aoe_hit_sound", "")
    self.aoe_damage_actor_sound   = SYS_GetParam(0, self.sec, "AOE_aoe_damage_actor_sound", "")
    self.particles                = SYS_GetParam(0, self.sec, "AOE_particles") and string.len(SYS_GetParam(0, self.sec, "AOE_particles")) > 0 and SYS_GetParam(0, self.sec, "AOE_particles") ~= "" and SYS_GetParam(0, self.sec, "AOE_particles")
    self.particles_offset         = str_explode(SYS_GetParam(0, self.sec, "AOE_particles_offset", ""), ",")
    if string.len(self.particles_offset[1]) == 0 then
        self.particles_offset = nil
    else
        self.particles_offset[1] = self.particles_offset[1] and tonumber(self.particles_offset[1]) or 0
        self.particles_offset[2] = self.particles_offset[2] and tonumber(self.particles_offset[2]) or 0
        self.particles_offset[3] = self.particles_offset[3] and tonumber(self.particles_offset[3]) or 0
    end

    -- Fastcall to collision detection check
    self.object:set_fastcall(self.fastcall, self)
    SendScriptCallback("on_molotov_init", self)
end

local tg = 0
function af_cell_grenade_binder:fastcall()
    local obj = self.object
    local id = obj:id()

    -- If object is in someone hands, dont check it
    if obj:parent() then
        if self.position then
            self.velocity = nil
            self.position = nil
            self.direction = nil
            self.travel_distance = nil
            self.tg = 0
            self.tg_time = 0
            self.fused = nil
        end
        if alife_molotovs[id] then
            self.last_parent_id = obj:parent():id()
        else
            if not self.last_parent_id then
                local p = obj:parent()
                print_tip("fused molotov thrown %s, parent id %s", id, p and p:id())
                if p and p:id() and alife_molotovs[p:id()] and alife_molotovs[p:id()].last_parent_id then
                    self.last_parent_id = alife_molotovs[p:id()].last_parent_id
                end
            end
        end
        return
    end

    -- Set initial position
    if not self.position then
        self.velocity = 0
        self.position = obj:position()
        self.direction = VEC_GROUND
        self.travel_distance = 0
        self.tg = 0
        self.tg_time = 0
        molotovs_free[id] = self
        switch_npc_check_approaching_molotov()
        return
    end

    -- Throttle updates
    self.tg = self.tg + device().time_delta

     -- Explode molotov if destroy time is near
    if self.fused and self.tg + device().time_delta * 4 > self.destroy_time then
        self:explode()
        return
    end

    if self.tg < self.tg_time then
        return
    end
    self.tg_time = self.tg + self.tg_period

    if self.fused == nil then
        self.fused = not alife_object(obj:id())
    end

    -- if force_destroy is true, the object will be destroyed
    -- Use destroy_object, thats what engine uses for bolts
    if self.force_destroy and not self.destroyed then
        self:explode()
        return
    end

    -- Calculate velocity, direction, position and travel distance
    -- Direction is (vectors) new position - old position
    -- Velocity is (scalar) length of direction vector
    local pos = obj:position()
    local dir = vector():set(pos):sub(self.position)
    self.velocity = dir:magnitude()
    self.direction = dir:normalize()
    self.position = pos
    self.travel_distance = self.travel_distance + self.velocity

    local velocity = self.velocity
    if self.advanced_velocity_check then

        -- Get surface normal that molotov directed to
        local surface_normal = demonized_geometry_ray.get_surface_normal(self.position, self.direction)

        if surface_normal then
            -- Invert the normal
            surface_normal:invert()

            -- Project velocity vector on normal
            velocity = self.velocity * self.direction:dotproduct(surface_normal)
        end
    end

    -- Offset a bit position of ray to shoot
    local ray_pos = vector():set(self.position):sub(vector():set(self.direction):mul(0.1))
    
    -- Shoot ray
    self.ray = self.create_collision_ray()
    local res = self.ray:get(ray_pos, self.direction)

    -- Check for material (engine edit required)
    local not_passable = true
    local result = res.result

    if  result
    and result.material_name
    and result.material_shoot_factor
    then
        local name = result.material_name
        local shoot_factor = result.material_shoot_factor

        if false 
        or string.find(name, "bush") 
        or string.find(name, "water")
        -- or self.ray:isMaterialFlag("flShootable") and shoot_factor <= 0.01
        -- or (self.ray:isMaterialFlag("flBounceable") and not self.ray:isMaterialFlag("flPassable"))
        then
            not_passable = false
        end
    end

    -- Debug
    -- print_tip("ray shot from %s, velocity %s, dist %s, in_contact %s, tg %s, tg_time %s", self:get_name(), self.velocity, res.distance, res.in_contact, self.tg, self.tg_time)

    -- If ray in contact range and enough velocity and enough distance traveled - blow up
    -- Set flag to destroy so it postpones on next update
    if res.in_contact and not_passable and self:can_be_blown(velocity)
    then
        print_tip("obj %s is in_contact %s, velocity %s", self:get_name(), res.in_contact, velocity)
        self.force_destroy = true
    end

    if self.fused then
        SendScriptCallback("on_molotov_fused_update", self)
    end
end
