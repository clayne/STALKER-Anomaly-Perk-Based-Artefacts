-- Perk Based Artefacts

-- Provides special perks and unique properties to junk artefacts
-- Beyond boundaries of traditional stats

-- Inspired by Fallout, Borderlands, Dark Souls games and Stalker mods like Golden Sphere (Золотой шар) and others
-- Written by demonized


local AC_ID = AC_ID
local alife_create_item = alife_create_item
local alife_release = alife_release
local alife_release_id = alife_release_id
local clamp = clamp
local copy_table = copy_table
local CreateTimeEvent = CreateTimeEvent
local empty_table = empty_table
local get_console = get_console
local give_info = give_info
local has_alife_info = has_alife_info
local iempty_table = iempty_table
local ini_sys = ini_sys
local IsAnomaly = IsAnomaly
local IsArtefact = IsArtefact
local IsMoveState = IsMoveState
local normalize = normalize
local particles_object = particles_object
local printf = printf
local random_float = random_float
local random_number = random_number
local RegisterScriptCallback = RegisterScriptCallback
local RemoveTimeEvent = RemoveTimeEvent
local ResetTimeEvent = ResetTimeEvent
local round_100 = round_100
local spairs = spairs
local SYS_GetParam = SYS_GetParam
local time_global = time_global
local UnregisterScriptCallback = UnregisterScriptCallback
local VEC_Y = VEC_Y
local vector_rotate_y = vector_rotate_y

local change_psy_health = arszi_psy.change_psy_health
local manage_psy_health = arszi_psy.manage_psy_health
local set_psy_health = arszi_psy.set_psy_health

local get_nearby_campfire = bind_campfire.get_nearby_campfire

local add_cam_effector = level.add_cam_effector
local add_pp_effector = level.add_pp_effector
local disable_input = level.disable_input
local enable_input = level.enable_input
local get_start_time = level.get_start_time
local get_time_factor = level.get_time_factor
local get_time_hours = level.get_time_hours
local get_time_minutes = level.get_time_minutes
local level_object_by_id = level.object_by_id
local remove_pp_effector = level.remove_pp_effector
local set_time_factor = level.set_time_factor

local get_weather_manager = level_weathers.get_weather_manager

local get_game_time = game.get_game_time
local translate_string = game.translate_string

local get_game_factor = game_difficulties.get_game_factor

local is_critical_bone = perk_based_artefacts_bone_mapper.is_critical_bone

local get_nearest_stalker = utils_obj.get_nearest_stalker

local play_snd = xr_effects.play_snd

local get_safe_sound_object = xr_sound.get_safe_sound_object
local set_sound_play = xr_sound.set_sound_play

local abs = math.abs
local ceil = math.ceil
local floor = math.floor
local max = math.max
local min = math.min
local random = math.random
local sqrt = math.sqrt

local function round(amount)
	return floor(amount + 0.5)
end

local string_find = string.find
local string_gsub = string.gsub

local dump = string.dump
local load = loadstring
local unpack = unpack
local pack = table.pack

local table_concat = table.concat
local table_insert = table.insert
local table_remove = table.remove
local table_sort = table.sort

local tg = 0 --time_global storage used for actor on update limiter
local actor_on_update_timer = 0.1 -- on update limiter, every 100ms actor_on_update is triggered
local actor_on_update_time = 0

local tg_lag = 0 --stores the time_global on game start and then used to correct timers for loaded time effects

local time_elapsed = 0 -- Time from game start used for effects and cooldowns
local time_factor = 6 -- Default time_factor

local actor_is_dying = false

hud_state = 1

local actor_last_money = 0

local c_id_ppe_blur = 5600
local c_id_ppe_black_infinite = 5606
local c_id_ppe_snd_shock = 5607
local c_id_ppe_actor_death = 445
local c_id_ppe_rcom_actor_death_quick = 446

local charge_threshold = 0.05 -- Below this charge the item has no battery

local last_hit
local last_npc_hit
local last_npc_hit_bone_index
local last_monster_hit
local last_monster_hit_bone_index

local debug_mode = true

-- Utils
local function trace(str, ...)
	if debug_mode then
		printf("Perk Based Artefacts: " .. str, ...)
	end
end

local function compare_arrays(t1, t2)
	if #t1 ~= #t2 then return false end
	for i = 1, #t1 do
		if t1[i] ~= t2[i] then return false end
	end
	return true
end

local function insert_n_times(t, item, n)
	local n = n or 1
	for i = 1, n do
		table_insert(t, item)
	end
end

local function get_random_array_element(t)
	return t[random(#t)]
end

local function array_keys(t)
	local res = {}
	local res_count = 1
	for k, v in pairs(t) do
		res[res_count] = k
		res_count = res_count + 1
	end
	return res
end

local function get_first_key(t)
	for k, v in pairs(t) do
		return k
	end
end

-- Based on an assumption that key order is undetermined and pseudorandom
local function get_random_key(t)
	return get_first_key(t)
	-- return get_random_array_element(array_keys(t))
end

local function get_random_element(t)
	return t[get_random_key(t)]
end

local function get_time_elapsed()
	--trace(time_factor)
	return floor(tonumber(get_game_time():diffSec(get_start_time())) / time_factor * 10) * 0.1
end

local function get_object_by_id(id) -- same as _g.script one but without spamming in console
	if not (id and type(id) == "number") then
		callstack()
		--printe("!ERROR get_object_by_id | id (%s) is invalid", id)
		return
	end

	if (id == AC_ID) then
		return db.actor
	end

	local obj = db.storage[id] and db.storage[id].object or level_object_by_id(id)
	if (not obj) then
		--printe("!ERROR get_object_by_id | no game object recieved from id (%s)", id)
		return
	end
	return obj
end

local function get_monster_clsid_and_kind(obj)
	return obj:clsid(), SYS_GetParam(0, obj:section(), "kind", 0)
end

local function get_current_weather()
	return get_weather_manager():get_curr_weather()
end

local function play_sound_on_actor(snd, volume, frequency)
	if not snd then
		trace("snd is nil")
		return
	end
	local actor = db.actor
	local snd = get_safe_sound_object(snd)
	if snd then
		snd:play(actor, 0, sound_object.s2d)
		snd.volume = volume or 1
		snd.frequency = frequency or 1
		return snd
	end
end

local smoothed_values = {}

--EMA smoothing for changing values
local default_smoothing = 25
local smoothing_alpha = 2.0 / (default_smoothing + 1)

local function set_smoothing(n)
	local n = math_max(n, 1)
	smoothing_alpha = 2.0 / (n + 1)
end

local function ema(key, value)
	smoothed_values[key] = smoothed_values[key] and smoothed_values[key] + smoothing_alpha * (value - smoothed_values[key]) or value
	--trace("EMA fired, key %s, target %s, current %s, going %s", key, value, smoothed_values[key], (value > smoothed_values[key] and "up" or "down"))
	return smoothed_values[key] 
end

local function look_at_nearest_npc(npc, actor)
	local actor = actor or db.actor
	local npc = npc or get_nearest_stalker(actor)
	if npc then
		local npc_position = npc:bone_position("bip01_head")
		local actor_position = actor:position()
		npc_position.x = ema("look_x", npc_position.x)
		npc_position.y = ema("look_y", npc_position.y)
		npc_position.z = ema("look_z", npc_position.z)
		-- npc_position.y = npc_position.y + 1
		actor:actor_look_at_point(npc_position)
	end
end

-- Artefacts
local iterate_belt
local process_artefacts
local refresh_artefacts
local refresh_artefacts_time_event_func
local refresh_state
local force_refresh_state

local artefacts = {}
local belt = {}

iterate_belt = function(actor)
	local artefacts = {}
	local belt = {}

	if has_alife_info("lucifer_active") then
		local af_lucifer = actor:object("af_lucifer")
		if af_lucifer then
			trace("lucifer exists, %s, %s", af_lucifer:id(), af_lucifer:name())
			artefacts.af_lucifer = {
				count = 1,
				ids = { af_lucifer:id() },
				names = { af_lucifer:name() }
			}
		else
			artefacts.af_lucifer = {
				count = 1,
				ids = {  },
				names = {  }
			}
		end
	end

	local function iterate_belt_function(owner, artefact)
		local sec = artefact:section()
		if artefacts[sec] then
			artefacts[sec].count = artefacts[sec].count + 1
			table_insert(artefacts[sec].ids, artefact:id())
			table_insert(artefacts[sec].names, artefact:name())
		else
			artefacts[sec] = {
				count = 1,
				ids = { artefact:id() },
				names = { artefact:name() }
			}
		end
		table_insert(belt, sec)
	end

	actor:iterate_belt(iterate_belt_function)
	table_sort(belt)
	return artefacts, belt
end

refresh_artefacts = function(force)
	trace("refresh artefacts triggered")
	local new_artefacts, new_belt = iterate_belt(db.actor)
	if force or not compare_arrays(belt, new_belt) then
		trace("artefacts are different, refreshing")
		artefacts = new_artefacts
		belt = new_belt
		return true
	end
	trace("artefacts are same")
	return false
end

-- For time events
refresh_artefacts_time_event_func = function(force)
	refresh_artefacts(force)
	return true
end

-- Callbacks
local callbacks = {}
local function register_callback(callback, callback_function, on_end_function)
	trace("registering callback %s", callback)
	RegisterScriptCallback(callback, callback_function)
	table_insert(callbacks, {
		callback = callback,
		func = callback_function,
		on_end = on_end_function
	})
end

local function unregister_callbacks()
	for i, props in pairs(callbacks) do
		trace("unregistering callback %s, %s", i, props.callback)
		UnregisterScriptCallback(props.callback, props.func)
		if props.on_end then
			props.on_end()
		end
		callbacks[i] = nil
	end
end

-- Effects
local cooldowns = {} -- Table of cooldowns of artefacts (["artefact"] = time_elapsed + cooldown)
local function add_cooldown(cooldown, name)
	trace("added cooldown, name %s, time %s, current_time %s", name, time_elapsed + (cooldown or 0), time_elapsed)
	cooldowns[name] = time_elapsed + (cooldown or 0)
end

local function check_cooldown(name)
	if not cooldowns[name] then return true end
	if time_elapsed >= cooldowns[name] then
		cooldowns[name] = nil
		return true
	end
	trace("cooldown not expired yet, name %s, time %s, current_time %s", name, cooldowns[name], time_elapsed)
	return false
end

local status_effects = {} -- Table of status effects of artefacts (["artefact"] = time_elapsed + cooldown)
local function add_status_effect(timer, effect, key)
	local t = {
		timer = time_elapsed + (timer or 0),
		effect = effect
	}
	if key then
		status_effects[key] = t
	else
		table_insert(status_effects, t)
	end
	trace("added status_effect, key %s, time %s, current_time %s", key, time_elapsed + (timer or 0), time_elapsed)
end

local function check_status_effect(key)
	if not status_effects[key] then return false end
	if time_elapsed >= status_effects[key].timer then
		status_effects[key] = nil
		return false
	end
	trace("status_effect active, key %s, time %s, current_time %s", key, status_effects[key].timer, time_elapsed)
	return true
end

-- Table of current active effects, contains tables of these {
-- timer = time_elapsed + timer in seconds, how long effect will be applied
-- effect = function(), the function of the effect
-- effect_function - string, dump of effect function to store in m_data
-- effect_args - array, args to effect_function
-- on_end = function(), the function on the expiration of effect
-- on_end_function - string, dump of on_end function to store in m_data
-- on_end_args - array, args to on_end_function
-- key - string, custom key to set in timed_effects table, otherwise will be used first available one
-- not_save - boolean, do not save in mdata }
-- this is the complex function intended to have persistence between saves, moving to different maps and so on, use if needed
-- no upvalues are allowed in the functions, best to reference globals by _G. lookup
-- The precision for both cooldown and timed effects is 0.1 or 100ms, making more precise timer or timed effect is pointless
local timed_effects = {}
local function add_timed_effect(timer, effect_function, effect_args, on_end_function, on_end_args, key, not_save)
	trace("current_time %s, adding effect %s", time_elapsed, time_elapsed + (timer or 0))

	local effect_args = effect_args or {}
	local on_end_args = on_end_args or {}
	local effect = {
		timer = time_elapsed + (timer or 0),
		effect = effect_function and function()
			effect_function(unpack(effect_args))
		end,
		effect_function = effect_function and dump(effect_function),
		effect_args = effect_args,
		on_end = on_end_function and function()
			on_end_function(unpack(on_end_args))
		end,
		on_end_function = on_end_function and dump(on_end_function),
		on_end_args = on_end_args,
		save = not not_save
	}

	if key then
		timed_effects[key] = effect
	else
		table_insert(timed_effects, effect)
	end
end

-- This is the simpler version of the function above if you do not care about persistence and saving states
local function add_simple_timed_effect(timer, effect_function, on_end_function, key)
	trace("current_time %s, adding effect %s", time_elapsed, time_elapsed + (timer or 0))

	local effect = {
		timer = time_elapsed + (timer or 0),
		effect = effect_function,
		on_end = on_end_function
	}

	if key then
		timed_effects[key] = effect
	else
		table_insert(timed_effects, effect)
	end
end

local function remove_timed_effect(key, on_end)
	if not timed_effects[key] then return end
	if on_end and timed_effects[key].on_end then
		timed_effects[key].on_end()
	end
	timed_effects[key] = nil
end

-- Processing the effects
-- Whatever lowest time is set for effect, it will be processed at least once on process cycle
local function process_timed_effects()
	for key, props in pairs(timed_effects) do
		if props.effect then
			props.effect()
		end
		trace("effect %s, timer %s, current_time %s", key, props.timer, time_elapsed)
		if props.timer < time_elapsed then
			trace("removing effect, effect timer %s, current_time %s", props.timer, time_elapsed)
			if props.on_end then
				props.on_end()
			end
			timed_effects[key] = nil
		end
	end
end

local speed_boosts = { -- Table of speed boosts for different artefacts
	af_generator = {
		name = "af_generator_boost",
		boost = 0.135
	},
	af_lucifer = {
		name = "af_lucifer_boost",
		boost = 0.35
	}
}

local add_speed = speed.add_speed
local remove_speed = speed.remove_speed
local function remove_speed_boosts()
	for boost, props in pairs(speed_boosts) do
		remove_speed(props.name)
	end
end

local artefact_props = { -- Special props of artefacts that are used in processing
	af_black_angel = {
		dice_roll = 0,
		reflect_chance = (function() -- LUT with chances to trigger by artefact count
			local t = {}
			for artefact_count = 1, 5 do
				-- Parabolic curve
				-- Progression is 20 -> 37.5 -> 50 -> 57.5 -> 60
				t[artefact_count] = (25 - 2.5 * artefact_count) * artefact_count - 2.5
			end
			return t
		end)(),
		valid_hits = { -- Valid hit types to trigger
			[hit.fire_wound] = true
		}
	},
	af_cell = {
		valid_hits = { -- Valid hit types to trigger
			[hit.fire_wound] = true
		}
	},
	af_elektron = {
		valid_hits = { -- Valid hit types to trigger
			[hit.shock] = true
		}
	},
	af_tapeworm = {
		valid_hits = { -- Valid hit types to trigger
			[hit.wound] = true,
			[hit.strike] = true
		},
		monster_animations = { -- Animations to trigger on hit (WIP)
			stalker = {
			    "norm_2_critical_hit_head_0",
			    "norm_2_critical_hit_torso_0",
			    "norm_1_critical_hit_head_0",
			    "norm_1_critical_hit_torso_0",
			},
			[clsid.zombie_s] = {
				"_stand_idle_0",
				"_stand_idle_1",
				"_stand_idle_2",
			},
			[clsid.dog_s] = {
				"critical_hit_head_0",
				"critical_hit_head_1",
				"critical_hit_head_2",
				"critical_hit_torso_0",
				"critical_hit_torso_1",
				"critical_hit_torso_2",
			},
			-- [1] = {
			-- 	clsid.zombie_s,
			-- 	clsid.cat_s,
			-- 	clsid.dog_s,
			-- 	"SM_PIRANHA",
			-- },
			-- [2] = {
			-- 	clsid.boar_s,
			-- 	clsid.flesh_s,
			-- 	clsid.fracture_s,
			-- 	clsid.pseudodog_s,
			-- 	clsid.psy_dog_s,
			-- },
			-- [3] = {
			-- 	clsid.bloodsucker_s,
			-- 	clsid.snork_s,
			-- 	"SM_KARLIK",
			-- 	"SM_PSYSUCKER",
			-- 	"SM_LURKER",
			-- 	"SM_VOLK",
			-- 	"SM_POLTER_CORP",
			-- 	135, -- Borya
			-- },
			-- [4] = {
			-- 	clsid.burer_s,
			-- 	clsid.controller_s,
			-- 	"SM_TARK",
			-- },
			-- [5] = {
			-- 	clsid.chimera_s,
			-- 	clsid.gigant_s,
			-- 	"SM_MEDVED",
			-- 	"SM_MONSTER_BOAR",
			-- 	"SM_VENDIGO",
			-- 	131, -- Bibliotekar
			-- }
		}
	},
	af_kogot = {
		monster_to_meat = { -- Associations of meat chunk to its monster (clsid or kind)
			["SM_GERMAN_SHEPHERD"] 			= "mutant_part_dog_meat",
			["SM_FOX"] 	 					= "mutant_part_dog_meat",
			["SM_VOLK"] 	 				= "mutant_part_psevdodog_meat",
			["SM_TARK"] 	 				= "mutant_part_flesh_meat",
			["SM_MEDVED"]					= "mutant_part_flesh_meat",
			["SM_MONSTER_BOAR"]				= "mutant_part_boar_chop",
			["SM_VENDIGO"]					= "mutant_part_flesh_meat",
			["SM_CHICKEN"]					= "mutant_part_tushkano_meat",
			["SM_LURKER"] 					= "mutant_part_lurker_meat",
			["SM_PSYSUCKER"]				= "mutant_part_psysucker_meat",
			[clsid.bloodsucker_s] 			= "mutant_part_krovosos_meat",
			[clsid.boar_s] 					= "mutant_part_boar_chop",
			[clsid.chimera_s]				= "mutant_part_chimera_meat",
			[clsid.dog_s]					= "mutant_part_dog_meat",
			[clsid.flesh_s]					= "mutant_part_flesh_meat",
			[clsid.pseudodog_s]				= "mutant_part_psevdodog_meat",
			[clsid.psy_dog_s]				= "mutant_part_psevdodog_meat",
			[clsid.rat_s]					= "mutant_part_tushkano_meat",
			[clsid.tushkano_s]				= "mutant_part_tushkano_meat"
		},
		valid_hits = { -- Valid hit types to trigger
			[hit.wound] = true
		},
		on_before_hit = function(self, actor, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			if not self.valid_hits[s_hit.type] then
				trace("Claw, not a valid hit type %s", s_hit.type)
				return
			end

			s_hit.power = s_hit.power * (1 + artefact_count * 0.1)
			local health_boost = s_hit.power * 0.0035 * artefact_count

			add_simple_timed_effect(1, function()
				actor:change_health(health_boost)
			end)
		end,
	},
	af_skull_miser = {
		money_items = (function() -- Money items to choose and spawn
			local t = {}
			insert_n_times(t, "roubles", 12)
			insert_n_times(t, "money_10_50", 7)
			insert_n_times(t, "money_50_100", 6)
			insert_n_times(t, "money_100_200", 6)
			insert_n_times(t, "money_200_300", 5)
			insert_n_times(t, "money_300_400", 4)
			insert_n_times(t, "money_400_500", 4)
			insert_n_times(t, "money_500_600", 3)
			insert_n_times(t, "money_600_700", 3)
			insert_n_times(t, "money_700_800", 2)
			insert_n_times(t, "money_800_900", 2)
			insert_n_times(t, "money_900_1000", 1)
			insert_n_times(t, "money_1000_5000", 1)
			insert_n_times(t, "money_5000_end", 1)
			return t
		end)(),
		head_bones = { -- NPC head bones for Miser's Skull perk
			[14] = true,
			[15] = true,
			[16] = true,
			[17] = true,
			[18] = true,
			[19] = true
		}
	},
	af_serofim = {
		ignore_all_damage_function = function(s_hit, bone_id, flags) -- "God Mode" function without g_god
			s_hit.power = 0.001
			s_hit.impulse = 0.001
		end,
		ignore_enemy_on_down_function = function(obj, enemy, flags) -- Remove evaluation for the down time
			if (enemy:id() == AC_ID) then
				flags.override = true
				flags.result = false
				return
			end
		end
	},
	af_star_phantom = {
		weapon_hidden = false, -- Check for weapon is hidden
		ignore_enemy_function = function(obj, enemy, flags) -- Remove evaluation
			if (enemy:id() == AC_ID) then
				flags.override = true
				flags.result = false
				return
			end
		end
	},
	af_dragon_eye = {
		dice_roll = 0,
		on_before_hit = function(actor, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			s_hit.power = 1000
		end,
		on_death = function(actor, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index)
			local npc_id = npc:id()
			trace("Victim's id: %s", npc_id)
			if npc_id == AC_ID then return end

			local npc_position = npc:position()
			local npc_level_vertex_id = npc:level_vertex_id()
			local npc_game_vertex_id = npc:game_vertex_id()

			local function explode(explode_id)
				local explode_obj = get_object_by_id(explode_id)
				if explode_obj then
					trace("explode_obj spawned")
					local sim = alife()
					sim:release(sim:object(npc_id))
					explode_obj:explode(0)
					trace("explode obj exploded")
					local gibs = particles_object("new_effects\\krovisha_main")
					if gibs and not gibs:playing() then
						gibs:play_at_pos(npc_position)
						local snd = get_safe_sound_object("perk_based_artefacts\\XDEATH" .. random(5))
						snd:play_at_pos(npc, npc_position, 0, sound_object.s3d)
						snd.frequency = random_float(0.95, 1.05)
					else
						trace("gibs not found")
					end
					return true
				end
				trace("explode_obj not spawned yet")
				return false
			end

			local explode_obj = alife_create_item("ied_new_blow", {npc_position, npc_level_vertex_id, npc_game_vertex_id, nil})
			CreateTimeEvent(explode_obj.id, explode_obj.id, 0, explode, explode_obj.id)
		end
	},
	af_fountain = {
		cashback_triggered = false, -- Trigger flag to reset time event
	},
	af_ball = {
		monster_tiers = { -- Monster Tiers opening by artefact count
			[1] = {
				clsid.zombie_s,
				clsid.cat_s,
				clsid.dog_s,
				"SM_PIRANHA",
			},
			[2] = {
				clsid.boar_s,
				clsid.flesh_s,
				clsid.fracture_s,
				clsid.pseudodog_s,
				clsid.psy_dog_s,
			},
			[3] = {
				clsid.bloodsucker_s,
				clsid.snork_s,
				"SM_KARLIK",
				"SM_PSYSUCKER",
				"SM_LURKER",
				"SM_VOLK",
				"SM_POLTER_CORP",
				135, -- Borya
			},
			[4] = {
				clsid.burer_s,
				clsid.controller_s,
				"SM_TARK",
			},
			[5] = {
				clsid.chimera_s,
				clsid.gigant_s,
				"SM_MEDVED",
				"SM_MONSTER_BOAR",
				"SM_VENDIGO",
				131, -- Bibliotekar
			}
		},
		monsters = {} -- Generated table to check if current monster is allowed to be kick
	},
	af_spaika = {
		weapon_shot = false, 
		damage_multiplier = 1,
		event_reset = function(self)
			--trace("Spike: event reset")
			self.weapon_shot = false
			RemoveTimeEvent("af_spaika", "af_spaika_reset")
		end,
		stack_reset = function(self)
			--trace("Spike: stack reset")
			self.damage_multiplier = 1
			self:event_reset()
			--trace("Spike, weapon_shot %s", self.weapon_shot)
		end,
		effect_reset = function(self)
			if self.damage_multiplier > 1 then
				local s_hit = hit()
				s_hit.power = 0.005
				s_hit.type = hit.shock
				s_hit.draftsman = db.actor
				db.actor:hit(s_hit)
				change_psy_health((self.damage_multiplier - 1) * -0.25)
				play_sound_on_actor("anomaly\\electra_hit1", 1, 1.5)
			else
				play_sound_on_actor("decoder", 1, 0.8)
			end
			self:stack_reset()
		end,
		on_before_hit = function(self, actor, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			s_hit.power = s_hit.power * self.damage_multiplier
			trace("Spike, Final Damage %s, bonus %s", s_hit.power, self.damage_multiplier)
			play_sound_on_actor("decoder", 1, self.damage_multiplier)
			
			self.damage_multiplier = self.damage_multiplier + (is_critical_bone(npc:clsid(), bone_id) and 0.04 + 0.02 * artefact_count or 0.01 + 0.02 * artefact_count)
			self:event_reset()
		end
	},
	af_sandstone = {
		valid_hits = { -- Valid hit types to trigger
			[hit.light_burn] = true,
			[hit.burn] = true,
			[hit.shock] = true,
			[hit.chemical_burn] = true
		},
		hit_types_sounds = { -- Hit type to sounds associations
			[hit.light_burn] = {
				"perk_based_artefacts\\flamer2",
			},
			[hit.burn] = {
				"perk_based_artefacts\\flamer1",
			},
			[hit.shock] = {
				"anomaly\\electra_blast",
				"anomaly\\electra_blast1"
			},
			[hit.chemical_burn] = {
				"anomaly\\bfuzz_hit",
				"anomaly\\buzz_hit"
			}
		},
		hit_types_particles = { -- Hit type to particles associations
			[hit.light_burn] = {
				"artefact\\artefact_zharka"
			},
			[hit.burn] = {
				"artefact\\artefact_zharka"
			},
			[hit.shock] = {
				"artefact\\artefact_electra"
			},
			[hit.chemical_burn] = {
				"artefact\\artefact_ameba"
			}
		},
		on_before_hit = function(self, actor, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			local actor_weapon = actor:active_item():name()
			if not check_status_effect("af_sandstone" .. actor_weapon) then
				trace("Sandstone, weapon %s not infused", actor_weapon)
				return
			end

			local effect = status_effects["af_sandstone" .. actor_weapon].effect
			local elemental_hit = hit(s_hit)
			s_hit.power = s_hit.power * 0.7
			elemental_hit.power = elemental_hit.power * 0.5
			elemental_hit.type = effect.hit_type
			elemental_hit.draftsman = npc
			npc:hit(elemental_hit)
			trace("Sandstone, effect power %s, hit_type %s", elemental_hit.power, elemental_hit.type)
			local gibs = particles_object(get_random_array_element(self.hit_types_particles[effect.hit_type]))
			local npc_position = npc:position()
			npc_position.y = npc_position.y + 0.5
			if gibs and not gibs:playing() then
				gibs:play_at_pos(npc_position)
			end
		end
	},
	af_cocoon = {
		valid_hits = { -- Valid hit types to trigger
			[hit.wound] = true,
			[hit.strike] = true
		},
		protection_stacks = 0,
		protection_bonus = (function()
			local t = {}
			t[0] = 1
			for stacks = 1, 10 do
				t[stacks] = 1 - round((10.277777 - 0.277777 * stacks) * stacks) * 0.01 -- 10 -> 75% parabolic curve
			end
			return t
		end)(),
		speed_penalty_name = "af_cocoon_speed_penalty",
		speed_penalty = (function()
			local t = {}
			for stacks = 1, 10 do
				t[stacks] = 1 - stacks * 0.1
			end
			return t
		end)(),
		stack_reset = function(self)
			trace("Cocoon: stack reset")
			self.protection_stacks = 0
			remove_speed(self.speed_penalty_name)
			play_sound_on_actor("perk_based_artefacts\\cocoon_free", 1, random_float(0.92, 1))
		end,
		on_before_hit = function(self, actor, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
			trace("Cocoon, stacks %s, reduction %s", self.protection_stacks, self.protection_bonus[self.protection_stacks])
			s_hit.power = s_hit.power * self.protection_bonus[self.protection_stacks]
			play_sound_on_actor("perk_based_artefacts\\cocoon" .. random(4), 1, random_float(0.92, 1))

			if self.protection_stacks < 10 then
				self.protection_stacks = min(self.protection_stacks + 1 * artefact_count, 10)
			end

			add_speed(self.speed_penalty_name, self.speed_penalty[self.protection_stacks], false, true)
			add_speed(self.speed_penalty_name, self.speed_penalty[self.protection_stacks], true, true)
			add_simple_timed_effect(10, nil, function()
				self:stack_reset()
			end, "af_cocoon_speed_penalty")
		end
	},
	af_lucifer = {
		ignore_tiers = (function()  -- Artefacts ignore list
			local t = {}
			t["af_serofim"] = true -- Seraphim
			t["af_lucifer"] = true -- Can't sacrifice itself
			ini_sys:section_for_each(function(sec)
				if SYS_GetParam(0, sec, "kind", "") == "i_arty_cont" then -- Exclude artefacts in containers
					t[sec] = true
				elseif SYS_GetParam(0, sec, "kind", "") == "i_attach" then -- Exclude attachments
					t[sec] = true
				elseif SYS_GetParam(1, sec, "quest_item", false) then -- Exclude quest items
					t[sec] = true
				end
			end)
			return t
		end)(),
		sacrifice_tiers = { -- Tier to condition restore associations
			[1] = {
				min = 3,
				max = 5,
				sound = {
					"perk_based_artefacts\\item-soul-take",
					"perk_based_artefacts\\item-soul-take1",
					"perk_based_artefacts\\item-soul-take2",
					"perk_based_artefacts\\item-soul-take3",
					"perk_based_artefacts\\item-soul-take4",
				}
			},
			[2] = {
				min = 6,
				max = 9,
				sound = {
					"perk_based_artefacts\\item-soul-red",
				}
			},
			[3] = {
				min = 10,
				max = 13,
				sound = {
					"perk_based_artefacts\\item-soul-gold",
				}
			},
			["af_fire_loop"] = {
				min = 20,
				max = 30,
				sound = {
					"perk_based_artefacts\\take-megahealth",
				}
			},
			["af_death_lamp"] = {
				min = 100,
				max = 100,
				sound = {
					"perk_based_artefacts\\item-wm-take-mono",
					"perk_based_artefacts\\item-wm-take",
				}
			}
		},
		condition = 1,
		check_lucifer = function(self)
			-- return has_alife_info("lucifer_active") and db.actor:object("af_lucifer")
			return artefacts.af_lucifer
		end,
		set_condition = function(self, amount, id)
			if not self:check_lucifer() then return end

			local id = id or artefacts.af_lucifer.ids[1]
			if not id then return end

			trace("lucifer id %s", id)
			trace("condition %s", self.condition)

			local af_lucifer = get_object_by_id(id)
			self.condition = amount < 1 and amount or 1
			af_lucifer:set_condition(self.condition)

			trace("new condition %s", af_lucifer:condition())
			return self.condition
		end,
		change_condition = function(self, amount, id)
			return self:set_condition(self.condition + amount, id)
		end,
		sacrifice_artefact = function(self, obj, id)
			local section = obj:section()
			if self.ignore_tiers[section] then return end
			local tier = self.sacrifice_tiers[section] or self.sacrifice_tiers[clamp(SYS_GetParam(2, section, "tier", 0), 0, 3)]
			if tier then
				alife_release_id(obj:id())
				CreateTimeEvent("refresh_artefacts", "refresh_artefacts", 0.15, refresh_artefacts_time_event_func, true)
				local snd = play_sound_on_actor(get_random_array_element(tier.sound), 1, random_float(0.93, 1))
				if section == "af_death_lamp" then
					-- Put Overcharge Bonus There
					if random(100) < 50 then

						local function die()
							local s_hit = _G.hit()
							s_hit.power = 10000
							s_hit.type = hit.explosion
							s_hit.impulse = 10000
							s_hit.direction = _G.VEC_Y
							s_hit.draftsman = db.actor

							bind_stalker_ext.invulnerable_time = _G.time_global() - 500  -- Prevent cheating death on save/load

							local function explode(explode_id)
								local explode_obj = _G.get_object_by_id(explode_id)
								if explode_obj then
									explode_obj:explode(0)
									if snd then snd:stop() end
									return true
								end
								return false
							end

							_G.printf("p %s, t %s, i %s, d %s, dm %s", s_hit.power, s_hit.type, s_hit.impulse, s_hit.direction, s_hit.draftsman)
							db.actor:hit(s_hit)

							local explode_obj = _G.alife_create_item("ied_new_blow", {db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), nil})
							_G.CreateTimeEvent(explode_obj.id, explode_obj.id, 0, explode, explode_obj.id)
						end

						add_timed_effect(1.8, nil, nil, die, nil, "af_death_lamp_die")
					end
				end
				return self:change_condition(random(tier.min, tier.max) * 0.01, id)
			end
		end
	}
}

-- Alias for Lucifer Check
local function check_lucifer()
	return artefact_props.af_lucifer:check_lucifer()
end

-- Functions for artefacts which provide perk bonuses continuously
local artefact_on_update_functions = {

	-- Sun, Perk: Solar Powered
	af_sun = function(actor, artefact_count, artefact_ids, artefact_names)
		local current_weather = get_current_weather()
		if not current_weather then
			trace("Sun: Weather not defined")
			return
		end

		local hours = get_time_hours()

		local health_boost = 0.00035
		local power_clear_boost = 0.002
		local power_partly_boost = 0.001
		local power_not_clear_penalty = -0.001

		if hours >= 21 or hours < 5 then
			actor:change_power(power_not_clear_penalty * artefact_count)
		else
			if current_weather == "clear" then
				actor:change_health(health_boost * artefact_count)
				actor:change_power(power_clear_boost * artefact_count)
			elseif current_weather == "partly" then
				actor:change_power(power_partly_boost * artefact_count)
			else
				actor:change_power(power_not_clear_penalty * artefact_count)
			end
		end
		trace("health %s, power %s", actor.health, actor.power)
	end,

	-- Heart, Perk: Will to Live
	af_ear = function(actor, artefact_count, artefact_ids, artefact_names)
		local health_threshold = 0.22 + 0.03 * artefact_count

		local actor_health = round_100(actor.health)
		if actor_health < health_threshold then
			local health = (health_threshold - actor_health) * 0.0042 * artefact_count * (artefact_props.af_lucifer:check_lucifer() and min(normalize(artefact_props.af_lucifer.condition, -0.25, 0.5), 1) or 1) --66% of reduction at 0 Lucifer condition
			actor:change_health(health)
			trace("firing Will to Live, health %s", health)
		end
	end,

	-- Moon, Perk: Friend of the Night
	af_moon = function(actor, artefact_count, artefact_ids, artefact_names)
		local hours = get_time_hours()
		if hours >= 5 then return end
		actor:change_power(0.001 * artefact_count)
	end,

	-- Signet, Perk: Light of Tranquility
	af_signet = function(actor, artefact_count, artefact_ids, artefact_names)
		local health_boost = 0.0005

		local nearby_camp = get_nearby_campfire(5, true)
		if nearby_camp and nearby_camp:is_on() then
			for i = 1, artefact_count do
				actor:change_health(health_boost)
				manage_psy_health()
				manage_psy_health()
				manage_psy_health()
			end
			trace("firing Signet, health %s", actor.health)
		end
	end,

	-- Atom, Perk: Arszi's Blessing
	af_atom = function(actor, artefact_count, artefact_ids, artefact_names)
		local power_boost = 0.02
		local radiation_cure = -0.00006

		local radiation = actor.radiation
		actor:change_power(radiation * power_boost * artefact_count)
		actor:change_radiation(radiation_cure * artefact_count)
	end,

	-- Generator, Perk: Godzilla is Approaching
	af_generator = function(actor, artefact_count, artefact_ids, artefact_names)
		local charge_boost = 0.0001

		--Pda, Detector and NVG slots
		if IsMoveState("mcSprint") then
			for i = 8, 10 do
				local item = actor:item_in_slot(i)
				if item then
					local condition = item:condition()
					if condition > charge_threshold then
						item:set_condition(condition + charge_boost * artefact_count)
					end
				end
			end
		end
	end,

	-- Sourpuss, Perk: What Colour Is Your Blood?
	af_kislushka = function(actor, artefact_count, artefact_ids, artefact_names)
		local bleeding_cure_boost = 0.00135 * artefact_count
		local satiety_drain = -0.0025 * artefact_count

		if actor.bleeding > 0 then
			trace("before bleeding %s", actor.bleeding)
			actor.bleeding = bleeding_cure_boost
			actor:change_satiety(satiety_drain)
			trace("after bleeding %s", actor.bleeding)
		end
	end,

	-- Сhain, Perk: The Weight Of Devotion
	af_chelust = function(actor, artefact_count, artefact_ids, artefact_names)
		local health_boost = 0.0002
		local power_boost = 0.0025

		actor:change_health(health_boost)
		actor:change_power(power_boost)

	end,

	-- Lucifer, Perk: The Lucifer Effect
	af_lucifer = function(actor, artefact_count, artefact_ids, artefact_names)
		local health_boost = 0.001
		local psy_boost = 0.005
		local power_boost = 0.01
		local bleeding_cure_boost = 0.0025
		local speed_boost = 0

		local degradation_rate = 0.00000029 * time_factor --25% per day is 0.00000029

		if not artefact_ids[1] then return end

		local af_lucifer = get_object_by_id(artefact_ids[1])
		local condition = artefact_props.af_lucifer.condition
		af_lucifer:set_condition(condition) -- Double set to set initial condition after loading state

		if condition > 0.5 then
			local normal_condition = normalize(condition, 0.5, 1)
			actor:change_health(health_boost * normal_condition)
			actor:change_power(power_boost * normal_condition)
			actor.bleeding = bleeding_cure_boost * normal_condition
			change_psy_health(psy_boost * normal_condition)
			speed_boost = speed_boosts.af_lucifer.boost * normal_condition
			local cw = (get_game_factor("weight") or 20) + 50 * normal_condition
			local mww = cw + (ceil(cw * 0.2) * 2)
			actor:set_actor_max_weight(cw)
			actor:set_actor_max_walk_weight(mww)
		else
			local normal_condition = normalize(condition, 0, 0.5) - 1
			actor:change_power(power_boost * normal_condition * 0.5)
			if condition < 0.4 then
				actor:change_health(health_boost * normal_condition * 0.35)
			end
			if condition < 0.0001 then
				condition = 0.011
				artefact_props.af_lucifer:set_condition(condition, artefact_ids[1])
				actor:set_health_ex(0)
				return
			end
		end

		add_speed(speed_boosts.af_lucifer.name, 1 + speed_boost, true, true)
		add_speed(speed_boosts.af_lucifer.name, 1 + speed_boost, false, true)

		artefact_props.af_lucifer.condition = condition - degradation_rate
		af_lucifer:set_condition(artefact_props.af_lucifer.condition)
		trace("Lucifer, condition: %s", artefact_props.af_lucifer.condition * 100)
	end,

}

--Functions for artefacts which provide perk bonuses after weapon fired
local artefact_on_weapon_fired_functions = {

	-- Knot, Perk: Superhot Deathloop
	-- Having last bullet in the magazine amplifies your reflexes
	-- Time around you slows down when you stop and moves normally only when you move
	-- The effect is short timed, if you missed the opportunity - too bad
	-- Weapons with no mags or only one bullet in the mag are ignored
	-- Multiple artefacts increase the magnitude of effect and slightly increase the duration
	-- SCRAPPED: no possibility to manipulate time factor outside of debug mode

	-- af_fire_loop = function(actor, artefact_count, artefact_ids, artefact_names, obj, wpn, ammo_elapsed, grenade_elapsed, ammo_type, grenade_type)
	-- 	local current_weapon = actor:active_item()
	-- 	if not current_weapon then
	-- 		trace("Knot, no current_weapon")
	-- 		return
	-- 	end

	-- 	local sec = current_weapon:section()
	-- 	local name = current_weapon:name()
	-- 	local mag_size = SYS_GetParam(2, sec, "ammo_mag_size", 0)
	-- 	if mag_size < 2 then
	-- 		trace("Knot, mag size is too small: %s", mag_size)
	-- 		return
	-- 	end

	-- 	local casted_weapon = current_weapon:cast_Weapon()
	-- 	if not casted_weapon then
	-- 		trace("Knot, no casted weapon")
	-- 		return
	-- 	end



	-- 	local ammo_elapsed = ammo_elapsed - 1
	-- 	trace(ammo_elapsed)
	-- 	remove_timed_effect(name, true)

	-- 	if ammo_elapsed == 1 and actor:alive() then
	-- 		local time = 1.5 + artefact_count
	-- 		local target_time_factor = 1 / (artefact_count + 1)
	-- 		add_timed_effect(time, function()
	-- 			get_console():execute("time_factor " .. target_time_factor)
	-- 		end, nil, function()
	-- 			get_console():execute("time_factor " .. 1)
	-- 		end, nil, name, true)
	-- 		trace("Knot, effect fired")
	-- 	else
	-- 		trace("Knot, effect not fired: elapsed %s, timed_effects %s, alive %s, available %s", ammo_elapsed, actor:alive())
	-- 	end

	-- end

	-- Spike, Perk: Critical Ascensi0n
	af_spaika = function(actor, artefact_count, artefact_ids, artefact_names, obj, wpn, ammo_elapsed, grenade_elapsed, ammo_type, grenade_type)
		trace("Spike, on_weapon_fired weapon_shot %s", artefact_props.af_spaika.weapon_shot)

		if artefact_props.af_spaika.weapon_shot then
			artefact_props.af_spaika:effect_reset()
			return
		end

		artefact_props.af_spaika.weapon_shot = true
		CreateTimeEvent("af_spaika", "af_spaika_reset", 2, function()
			trace("Spike, Creating time event")
			artefact_props.af_spaika:effect_reset()
			return true
		end)
	end,

	-- Sandstone, perk: Zone Infusion
	af_sandstone = function(actor, artefact_count, artefact_ids, artefact_names, obj, wpn, ammo_elapsed, grenade_elapsed, ammo_type, grenade_type)
		local actor_weapon = actor:active_item():name()
		if not check_status_effect("af_sandstone" .. actor_weapon) then
			trace("Sandstone, weapon %s not infused", actor_weapon)
			return
		end

		local hit_type = status_effects["af_sandstone" .. actor_weapon].effect.hit_type
		local sandstone = artefact_props.af_sandstone
		play_sound_on_actor(get_random_array_element(sandstone.hit_types_sounds[hit_type]), 0.35, random_float(0.95, 1.05))
	end
}

-- Functions for artefacts which provide perk bonuses on item use
local artefact_on_item_use_functions = {

	-- Grapes, Perk: Necessary Gluttony
	af_grapes = function(actor, artefact_count, artefact_ids, artefact_names, obj)
		if not obj then
			trace("Food object not found")
			return
		end

		local health_boost = 0.015

		local sec = obj:section()
		local satiety_increase = SYS_GetParam(2, sec, "eat_satiety", 0) * health_boost
		if satiety_increase > 0 then
			add_timed_effect(1 * artefact_count, function(satiety_increase)
				db.actor:change_health(satiety_increase)
				_G.printf("health increased by %s", satiety_increase)
			end, {satiety_increase})
		end
	end

}

function af_serofim_cheat_death()
	local actor = db.actor
	local c_id_ppe_black_infinite = 5606
	local hud_state = perk_based_artefacts.hud_state

	bind_stalker_ext.invulnerable_time = time_global()
	level.enable_input()
	level.remove_pp_effector(c_id_ppe_black_infinite)
	get_console():execute("snd_volume_eff " .. _G.amb_vol)
	get_console():execute("snd_volume_music " .. _G.mus_vol)
	_G.mus_vol = 0
	_G.amb_vol = 0
	get_console():execute("hud_draw " .. hud_state)
	CreateTimeEvent("af_serofim_cheat_death", "af_serofim_cheat_death", 0.5, function()
		xr_effects.play_snd(actor, nil, {[1] = "perk_based_artefacts\\fast_fire_dusk"})
		return true
	end)
end

-- Functions for artefacts which provide perk bonuses on before actor death
local artefact_on_before_death_functions = {

	-- Seraphim, Perk: Rain of Revival
	af_serofim = function(actor, artefact_count, artefact_ids, artefact_names, whoID, flags)
		if actor_is_dying == true then
			flags.ret_value = false
			return
		end

		actor_is_dying = true
		disable_input()
		bind_stalker_ext.invulnerable_time = time_global() + 10000

		if actor:is_talking() then
			actor:stop_talk()
		end

		hud_state = get_console():get_bool("hud_draw") and 1 or 0
		get_console():execute("hud_draw 0")

		local actor_weapon = actor:active_item()

		if actor_weapon then
			actor:drop_item(actor_weapon)
		end

		add_cam_effector("camera_effects\\surge_02.anm", 444, false, "perk_based_artefacts.af_serofim_cheat_death")
		add_pp_effector("actor_death.ppe", c_id_ppe_actor_death, true)
		add_pp_effector("rcom_actor_death_quick.ppe", c_id_ppe_rcom_actor_death_quick, true)

		local amb_vol_coeff = 1
		_G.mus_vol = get_console():get_float("snd_volume_music")
		_G.amb_vol = get_console():get_float("snd_volume_eff")
		add_simple_timed_effect(0.8, function()
			amb_vol_coeff = amb_vol_coeff - 0.08
			get_console():execute("snd_volume_eff " .. _G.amb_vol * amb_vol_coeff)
		end)
		get_console():execute("snd_volume_music 0")

		flags.ret_value = false

		RegisterScriptCallback("actor_on_before_hit", artefact_props.af_serofim.ignore_all_damage_function)
		RegisterScriptCallback("on_enemy_eval", artefact_props.af_serofim.ignore_enemy_on_down_function)

		local function revive()
			actor:set_health_ex(0.5)
			actor.power = 1
			actor.radiation	= 0
			actor.bleeding = 1
			actor.psy_health = 1
			set_psy_health(1)
		end

		revive()
		CreateTimeEvent("af_serofim_break_sound", "af_serofim_break_sound", 1.3, function()
			play_snd(actor, nil, {[1] = "material\\bottle\\collide\\bottle_break_1"})
			return true
		end)
		CreateTimeEvent("af_serofim", "af_serofim", 2, function()
			trace("unregistering callback")
			UnregisterScriptCallback("on_enemy_eval", artefact_props.af_serofim.ignore_enemy_on_down_function)
			add_simple_timed_effect(5, revive, function()
				remove_pp_effector(c_id_ppe_blur)
				remove_pp_effector(c_id_ppe_snd_shock)
				remove_pp_effector(c_id_ppe_actor_death)
				remove_pp_effector(c_id_ppe_rcom_actor_death_quick)
				UnregisterScriptCallback("actor_on_before_hit", artefact_props.af_serofim.ignore_all_damage_function)
				actor_is_dying = false
			end)
			return true
		end)
		if artefact_ids[1] then
			alife_release_id(artefact_ids[1])
			CreateTimeEvent("refresh_artefacts", "refresh_artefacts", 0.15, refresh_artefacts_time_event_func, true)
		end
	end

}

-- Functions for artefacts which provide perk bonuses on before actor hit
local artefact_on_before_hit_functions = {

	-- Black Angel, perk: Dodge This
	af_black_angel = function(actor, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
		if not artefact_props.af_black_angel.valid_hits[s_hit.type] then
			trace("Black Angel, not a valid hit type %s", s_hit.type)
			return
		end

		artefact_props.af_black_angel.dice_roll = random(100)
		if artefact_props.af_black_angel.dice_roll <= artefact_props.af_black_angel.reflect_chance[artefact_count] then
			s_hit.power = 0.001
		end
	end,

	-- Electron, Perk: Crank High Voltage
	af_elektron = function(actor, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
		if not artefact_props.af_elektron.valid_hits[s_hit.type] then
			trace("Electron, not a valid hit type %s", s_hit.type)
			return
		end
		for i = 8, 10 do
			local item = actor:item_in_slot(i)
			if item then
				item:set_condition(1)
			end
		end
		actor:iterate_inventory(function(npc, item)
			local sec = item:section()
			if (IsItem("device", sec) or sec == "batteries_dead") and random(100) < 40 then
				item:set_condition(1)
			end
		end, actor)

		local function infinite_sprint()
			db.actor:change_power(1)
		end

		if random(100) < 15 then
			play_sound_on_actor("perk_based_artefacts\\lyutii", 0.7)
			add_timed_effect(12, infinite_sprint)
		else
			play_sound_on_actor("perk_based_artefacts\\rnd_scr3", 1)
			add_timed_effect(6, infinite_sprint)
		end
	end,

	-- Cell, Perk: Disintegrator
	af_cell = function(actor, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
		if not artefact_props.af_cell.valid_hits[s_hit.type] then
			trace("Cage, not a valid hit type %s", s_hit.type)
			return
		end

		local rad_k = 0.15 * artefact_count
		local power = s_hit.power
		s_hit.power = s_hit.power * (1 - rad_k)
		power = power - s_hit.power
		local rad_amount = power * 0.1
		trace("Cell: resulted radiation %s", rad_amount)
		actor:change_radiation(rad_amount)
		play_sound_on_actor("anomaly\\electra_hit" .. get_random_array_element({"", "1"}), 1, 1 - (artefact_count - 1) * 0.1)

		local function rad_sound()
			play_sound_on_actor("detectors\\geiger_" .. random(8), 1)
			return true
		end

		for i = 1, artefact_count do
			CreateTimeEvent("af_cell" .. i, "af_cell" .. i, random_float(0.15, 0.3) * i, rad_sound)
		end
	end,

	-- Cocoon, perk: Stone Skin
	af_cocoon = function(actor, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
		if not artefact_props.af_cocoon.valid_hits[s_hit.type] then
			trace("Cocoon, not a valid hit type %s", s_hit.type)
			return
		end

		artefact_props.af_cocoon:on_before_hit(actor, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
	end,

	-- Lucifer, Perk: The Lucifer Effect
	af_lucifer = function(actor, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
		s_hit.power = s_hit.power * (1 - normalize(artefact_props.af_lucifer.condition, 0.5, 1.5)) -- 50% reduction at 100% condition
	end

}

-- Functions for artefacts which provide perk bonuses on actor hit
local artefact_on_hit_functions = {

	-- Black Angel, perk: Dodge This
	af_black_angel = function(actor, artefact_count, artefact_ids, artefact_names, obj, amount, who, last_hit)
		if artefact_props.af_black_angel.dice_roll > artefact_props.af_black_angel.reflect_chance[artefact_count] then
			trace("Black Angel not triggered, dice roll %s, chance %s", artefact_props.af_black_angel.dice_roll, artefact_props.af_black_angel.reflect_chance[artefact_count])
			return
		end
		if not (
			last_hit and
			artefact_props.af_black_angel.valid_hits[last_hit.type] and
			who and
			obj
		) then
			trace("Black Angel not triggered, not valid hit")
			return
		end

		local s_hit = hit(last_hit)
		s_hit.power = s_hit.power * 0.35
		s_hit.draftsman = who

		who:hit(s_hit)
		trace("hit %s, last_hit %s", s_hit.power, last_hit.power)
	end,

	-- Tapeworm, Perk: Stunner
	af_tapeworm = function(actor, artefact_count, artefact_ids, artefact_names, obj, amount, who, last_hit)
		if not check_cooldown("af_tapeworm") then
			trace("Tapeworm not triggered, cooldown active")
			return
		end

		if not (
			last_hit and
			artefact_props.af_tapeworm.valid_hits[last_hit.type] and
			who and
			not IsAnomaly(who) and
			obj
		) then
			trace("Tapeworm not triggered, not valid hit")
			return
		end

		local who_id = who:id()
		local who_position = who:position()

		local s_hit = hit(last_hit)
		s_hit.bone = "bip01_spine"
		s_hit.power = 0.01 * artefact_count
		s_hit.draftsman = who

		local effect_time = 0.5 + 2 * artefact_count

		local monster_anims = artefact_props.af_tapeworm.monster_animations
		local monster_cls, monster_kind = get_monster_clsid_and_kind(who)

		local anims = IsStalker(who) and monster_anims.stalker or monster_anims[monster_kind] or monster_anims[monster_cls]

		local function ignore_enemy_function(obj, enemy, flags) -- Remove evaluation
			if obj:id() == who_id then
				flags.override = true
				flags.result = false
				return
			end
		end

		RegisterScriptCallback("on_enemy_eval", ignore_enemy_function)

		if IsStalker(who) then
			s_hit.power = s_hit.power * 0.05

			local function hit_enemy(time)
				who_position = who:position()

				local snd = get_safe_sound_object("anomaly\\electra_hit" .. get_random_array_element({"", "1"}))
				snd:play_at_pos(who, who_position, 0, sound_object.s3d)
				snd.frequency = random_float(0.95, 1.05)

				if who:alive() then
					who:set_movement_type(move.stand)
					who:set_body_state(move.standing)
					who:set_mental_state(anim.panic)
					who:hit(s_hit)

					if anims then
			        	who:play_cycle(get_random_array_element(anims), true)
			        end

					trace("time %s, hit %s, last_hit %s", time, s_hit.power, last_hit.power)
				else
					if who:get_physics_shell() then
						who:get_physics_shell():apply_force(random(1000, 2000), random(2000, 4000), random(1000, 2000))
					end
				end
				return true
			end

			for i = 0, effect_time, 0.05 do
				CreateTimeEvent("af_tapeworm" .. who_id, "af_tapeworm" .. who_id .. i, i, hit_enemy, i)
			end
		else
			local snd = get_safe_sound_object("anomaly\\electra_blast")
			snd:play_at_pos(who, who_position, 0, sound_object.s3d)
			snd.volume = 0.7
			snd.frequency = random_float(1.1, 1.2)

			local function hit_enemy(time)
				who_position = who:position()
				who:hit(s_hit)

				trace("time %s, hit %s, last_hit %s", time, s_hit.power, last_hit.power)
				return true
			end

			hit_enemy(0)
		end

		CreateTimeEvent("af_tapeworm" .. who_id, "af_tapeworm" .. who_id .. "eval", effect_time + 0.1, function()
			-- Possible unstuck Fix
			-- TeleportObject(who:id(), who:position(), who:level_vertex_id(), who:game_vertex_id())
			UnregisterScriptCallback("on_enemy_eval", ignore_enemy_function)
			return true
		end)

		add_cooldown(2, "af_tapeworm")
	end,

	-- Sandstone, perk: Zone Infusion
	af_sandstone = function(actor, artefact_count, artefact_ids, artefact_names, obj, amount, who, last_hit)
		if not (last_hit and artefact_props.af_sandstone.valid_hits[last_hit.type]) then
			trace("Sandstone, not valid hit type")
			return
		end

		if not (who and IsAnomaly(who)) then
			trace("Sandstone, not Anomaly %s", who:section())
			return
		end

		local actor_weapon = actor:active_item()
		if not actor_weapon then
			trace("Sandstone, no active actor_weapon")
			return
		end

		add_status_effect(180, {
			weapon_name = actor_weapon:name(),
			hit_type = last_hit.type
		}, "af_sandstone" .. actor_weapon:name())
	end

}

-- Functions for artefacts which provide perk bonuses on before npc hit
local artefact_on_npc_before_hit_functions = {

	-- Claw, Perk: Bloodlust
	af_kogot = function(actor, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
		artefact_props.af_kogot:on_before_hit(actor, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
	end,

	-- Dragon's Eye, Perk: Good ol' Ultra-Violence
	af_dragon_eye = function(actor, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
		artefact_props.af_dragon_eye.dice_roll = random(100)
		local chance = 5 * artefact_count
		if artefact_props.af_dragon_eye.dice_roll > chance then
			trace("Dragon Eye not triggered, dice roll %s, chance %s", artefact_props.af_dragon_eye.dice_roll, chance)
			return
		end
		artefact_props.af_dragon_eye.on_before_hit(actor, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
	end,

	-- Spike, Perk: Critical Ascensi0n
	af_spaika = function(actor, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
		artefact_props.af_spaika:on_before_hit(actor, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
	end,

	-- Sandstone, perk: Zone Infusion
	af_sandstone = function(actor, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
		artefact_props.af_sandstone:on_before_hit(actor, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
	end,

}

-- Functions for artefacts which provide perk bonuses on npc death
local artefact_on_npc_death_functions = {

	-- Miser's Skull, Perk: Crack the jackpot
	af_skull_miser = function(actor, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index)
		if not (last_npc_hit and last_npc_hit_bone_index and artefact_props.af_skull_miser.head_bones[last_npc_hit_bone_index]) then
			trace("Miser's Skull not triggered, bone index %s", last_npc_hit_bone_index)
			return
		end

		local npc_level_vertex_id = npc:level_vertex_id()
		local npc_game_vertex_id = npc:game_vertex_id()

		local money_items = artefact_props.af_skull_miser.money_items
		local money_fountain_minimal_force = 125
		local money_fountain_force = 200

		local function money_fountain(money_item_id)
			local money = get_object_by_id(money_item_id)
			if money then
				trace("money spawned")
				local random_force = random()
				money:get_physics_shell():apply_force(
					money_fountain_minimal_force + random_force * money_fountain_force,
					(money_fountain_minimal_force + random_force * money_fountain_force) * 5,
					money_fountain_minimal_force + random_force * money_fountain_force)
				return true
			end
			trace("money not spawned yet")
			return false
		end

		for i = 1, artefact_count * 3 do
			local money_position = npc:position()
			local money_direction = npc:direction()
			money_direction = vector_rotate_y(money_direction, random(-180, 180))
			money_position.x = money_position.x + money_direction.x * random_float(0.3, 0.5)
			money_position.y = money_position.y + money_direction.y + 2
			money_position.z = money_position.z + money_direction.z * random_float(0.3, 0.5)
			local money_item = alife_create_item(get_random_array_element(money_items), {money_position, npc_level_vertex_id, npc_game_vertex_id, nil})
			CreateTimeEvent(money_item.id, money_item.id, 0, money_fountain, money_item.id)
		end

		artefact_props.af_lucifer:change_condition(0.005)
	end,

	-- Dragon's Eye, Perk: Good ol' Ultra-Violence
	af_dragon_eye = function(actor, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index)
		local chance = 5 * artefact_count
		if artefact_props.af_dragon_eye.dice_roll > chance then
			trace("Dragon Eye not triggered, dice roll %s, chance %s", artefact_props.af_dragon_eye.dice_roll, chance)
			return
		end

		artefact_props.af_dragon_eye.on_death(actor, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index)
		artefact_props.af_lucifer:change_condition(0.01)
	end

}

-- Functions for artefacts which provide perk bonuses on before monster hit
local artefact_on_monster_before_hit_functions = {

	-- Claw, Perk: Bloodlust
	af_kogot = function(actor, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
		artefact_props.af_kogot:on_before_hit(actor, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
	end,

	-- Dragon's Eye, Perk: Good ol' Ultra-Violence
	af_dragon_eye = function(actor, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
		artefact_props.af_dragon_eye.dice_roll = random(100)
		local chance = 5 * artefact_count
		if artefact_props.af_dragon_eye.dice_roll > chance then
			trace("Dragon Eye not triggered, dice roll %s, chance %s", artefact_props.af_dragon_eye.dice_roll, chance)
			return
		end
		artefact_props.af_dragon_eye.on_before_hit(actor, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
	end,

	-- Spike, Perk: Critical Ascensi0n
	af_spaika = function(actor, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
		artefact_props.af_spaika:on_before_hit(actor, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
	end,

	-- Sandstone, perk: Zone Infusion
	af_sandstone = function(actor, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
		artefact_props.af_sandstone:on_before_hit(actor, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
	end,

}

-- Functions for artefacts which provide perk bonuses on monster death
local artefact_on_monster_death_functions = {

	-- Claw, Perk: Bloodlust
	af_kogot = function(actor, artefact_count, artefact_ids, artefact_names, monster, who, last_monster_hit, last_monster_hit_bone_index)
		local monster_cls, monster_kind = get_monster_clsid_and_kind(monster)
		local monster_meat = artefact_props.af_kogot.monster_to_meat[monster_kind] or artefact_props.af_kogot.monster_to_meat[monster_cls]
		if not (last_monster_hit and artefact_props.af_kogot.valid_hits[last_monster_hit.type] and monster_meat) then
			trace("Claw not triggered")
			return
		end

		local monster_level_vertex_id = monster:level_vertex_id()
		local monster_game_vertex_id = monster:game_vertex_id()

		for i = 1, artefact_count do
			local meat_position = monster:position()
			local meat_direction = monster:direction()
			meat_direction = vector_rotate_y(meat_direction, random(-180, 180))
			meat_position.x = meat_position.x + meat_direction.x * random_float(0.5, 0.7)
			meat_position.y = meat_position.y + meat_direction.y + 1
			meat_position.z = meat_position.z + meat_direction.z * random_float(0.5, 0.7)
			local meat_item = alife_create_item(monster_meat, {meat_position, monster_level_vertex_id, monster_game_vertex_id, nil})
		end
	end,

	-- Dragon's Eye, Perk: Good ol' Ultra-Violence
	af_dragon_eye = function(actor, artefact_count, artefact_ids, artefact_names, monster, who, last_monster_hit, last_monster_hit_bone_index)
		local chance = 10 * artefact_count
		if artefact_props.af_dragon_eye.dice_roll > chance then
			trace("Dragon Eye not triggered, dice roll %s, chance %s", artefact_props.af_dragon_eye.dice_roll, chance)
			return
		end
		artefact_props.af_dragon_eye.on_death(actor, artefact_count, artefact_ids, artefact_names, monster, who, last_monster_hit, last_monster_hit_bone_index)

		artefact_props.af_lucifer:change_condition(0.01)
	end

}

-- Functions for artefacts which provide perk bonuses on trade
local artefact_on_trade_functions = {

	-- Fountain, Perk: Letyshops Time
	af_fountain = function(actor, artefact_count, artefact_ids, artefact_names, item, sell_bye)
		if sell_bye then
			actor_last_money = actor:money()
			trace("Fountain not fired, selling item")
			return
		end

		if artefact_props.af_fountain.cashback_triggered then
			ResetTimeEvent("af_fountain_cashback", "af_fountain_cashback", 0.15)
		else
			trace("Fountain fired")

			local function cashback()
				local money = actor:money()
				trace("Actor last money %s, actor current money %s", actor_last_money, money)
				local cashback = round((actor_last_money - money) * 0.02 * artefact_count)
				if cashback < 1 then
					trace("Fountain not fired, not enough money")
					actor_last_money = money
					return true
				end

				trace("Fountain, Money given %s", cashback)
				actor:give_money(cashback)

				local news_text = translate_string(tostring(cashback))
				local news_caption = translate_string("general_in_money")
				local news_ico = "ui_inGame2_Dengi_polucheni"
				set_sound_play(AC_ID, "pda_tips")
				actor:give_game_news(news_caption, news_text, news_ico, 0, 7000, 0)

				artefact_props.af_fountain.cashback_triggered = false
				actor_last_money = actor:money()

				ui_inventory.GUI:On_Item_Update()
				return true
			end

			CreateTimeEvent("af_fountain_cashback", "af_fountain_cashback", 0.15, cashback)
			artefact_props.af_fountain.cashback_triggered = true
		end
	end

}

-- Functions for artefacts which provide perk bonuses on equip
local artefact_on_equip_functions = {

	-- Phantom Star, Perk: Phantom Pacifist
	af_star_phantom = function(actor, artefact_count, artefact_ids, artefact_names)
		if not artefact_props.af_star_phantom.weapon_hidden then
			actor:hide_weapon()
			artefact_props.af_star_phantom.weapon_hidden = true
		end
		register_callback("on_enemy_eval", artefact_props.af_star_phantom.ignore_enemy_function, function()
			actor:restore_weapon()
			artefact_props.af_star_phantom.weapon_hidden = false
		end)
	end,

	-- Generator, Perk: Godzilla is Approaching
	af_generator = function(actor, artefact_count, artefact_ids, artefact_names)
		add_speed(speed_boosts.af_generator.name, 1 + speed_boosts.af_generator.boost * (artefact_count - 1), true, true)
	end,

	-- Ball, Perk: Kick Deez Nutz
	af_ball = function(actor, artefact_count, artefact_ids, artefact_names)
		empty_table(artefact_props.af_ball.monsters)
		for i = 1, artefact_count do
			for j, monster in ipairs(artefact_props.af_ball.monster_tiers[i]) do
				artefact_props.af_ball.monsters[monster] = true
			end
		end
	end,

	-- Knot, Perk: Deal with the Devil
	af_fire_loop = function(actor, artefact_count, artefact_ids, artefact_names)
		if not has_alife_info("lucifer_active") then
			alife_create_item("af_lucifer", actor)
			alife_release_id(artefact_ids[1])
			give_info("lucifer_active")
			play_sound_on_actor("perk_based_artefacts\\creep_laugh")
			CreateTimeEvent("lucifer_activate", "lucifer_activate", 0.15, force_refresh_state)
		end
	end,

}

-- Special monkey patches for some artefacts to make their effects work
-- Custom Dynamic Functors for Lucifer
local function check_lucifer_condition(obj)
	return IsArtefact(obj) and check_lucifer()
end

local function check_sacrifice(obj)
	if not artefact_props.af_lucifer.ignore_tiers[obj:section()] then
		trace("%s is valid", obj:section())
		return "st_pba_sacrifice"
	end
end

local function lucifer_sacrifice(obj)
	return artefact_props.af_lucifer:sacrifice_artefact(obj)
end

local add_functor = custom_functor_autoinject.add_functor
add_functor("lucifer", check_lucifer_condition, check_sacrifice, check_lucifer_condition, lucifer_sacrifice)

-- Patch for Ball for kicking monsters
local use_kick = bind_monster.generic_object_binder.use_kick
bind_monster.generic_object_binder.use_kick = function(self, obj, who)
	if who:id() ~= AC_ID then
		use_kick(self, obj, who)
		return
	end

	if not artefacts.af_ball then
		use_kick(self, obj, who)
		return
	end

	if not (obj:alive() and check_cooldown("af_ball")) then return end

	local actor = db.actor
	local pos = actor:position()
	local h = hit()
	local direction = device().cam_dir
	local artefact_count = artefacts.af_ball.count
	local magnitude = artefact_count * 50
	direction.x = direction.x * 1000 * magnitude
	direction.y = random_float(0.1, 0.2) * 5000 * magnitude
	direction.z = direction.z * 1000 * magnitude
	h.power = 10000
	h.direction = direction
	h.bone = "bip01_spine"
	h.draftsman = obj
	h.impulse = 10000	--6000
	h.type = hit.wound
	obj:hit(h)

	local obj_id = obj:id()

	local function fly(obj_id)
		local monster = get_object_by_id(obj_id)
		if monster and not monster:alive() and monster:get_physics_shell() then
			trace("monster dead, physics shell works")
			monster:get_physics_shell():apply_force(direction.x, direction.y, direction.z)
			play_sound_on_actor("perk_based_artefacts\\BIGGIB0" .. random(6), 1, random_float(0.9, 1.0))
			local position = monster:position()
			position.y = position.y + 1

			if artefact_count <= 2 then
				play_sound_on_actor("perk_based_artefacts\\BONSNAP" .. random(8), 0.1 + 0.2 * (artefact_count - 1), random_float(0.9, 1.0))
				local gibs = particles_object("artefact\\effects\\af_idle_dist")
				if gibs and not gibs:playing() then
					gibs:play_at_pos(position)
				end
			else

				if artefact_count > 2 then
					play_sound_on_actor("perk_based_artefacts\\BONSNAP" .. random(8), 0.7, random_float(0.9, 1.0))
					local gibs = particles_object("artefact\\artefact_mincer")
					if gibs and not gibs:playing() then
						gibs:play_at_pos(position)
					end
				end

				if artefact_count > 4 then
					play_sound_on_actor("perk_based_artefacts\\GNTEAR0" .. random(2), 0.75, random_float(0.9, 1.0))
					local gibs = particles_object("artefact\\artefact_gravi")
					if gibs and not gibs:playing() then
						gibs:play_at_pos(position)
					end
				end

			end

			return true
		end
		trace("monster not dead yet")
		return false
	end
	CreateTimeEvent(obj_id, obj_id, 0, fly, obj_id)

	add_cooldown(1 + 1 * artefact_count, "af_ball")
end

-- Patch for Ball for kicking monsters
local monster_update = bind_monster.generic_object_binder.update
bind_monster.generic_object_binder.update = function(self, delta)
	monster_update(self, delta)
	if not artefacts.af_ball or not self.object:alive() then return end

	local monster_cls, monster_kind = get_monster_clsid_and_kind(self.object)
	if artefact_props.af_ball.monsters[monster_kind] or artefact_props.af_ball.monsters[monster_cls] then
		self.object:set_callback(callback.use_object, self.use_kick, self)
		self.object:set_tip_text(self.object:set_tip_text(game.translate_string("st_body_kick")))
	end
end

-- Patch for First Person Death
if ayykyu_fp_death and ayykyu_fp_death.actor_on_before_death then
	local fp_death = ayykyu_fp_death.actor_on_before_death
	ayykyu_fp_death.actor_on_before_death = function(whoID, flags)
		for artefact, props in pairs(artefacts) do
			if artefact_on_before_death_functions[artefact] then -- prevent dying with First Person Death mod enabled
				return
			end
		end
		fp_death(whoID, flags)
	end
end

-- Patch for Food Drug Drink Animations
if enhanced_animations and enhanced_animations.use_item and enhanced_animations.call_my_slot_back then

	local fdda_use_item = enhanced_animations.use_item
	enhanced_animations.use_item = function(obj)
		if artefacts.af_star_phantom then
			artefact_props.af_star_phantom.weapon_hidden = false
			db.actor:restore_weapon()
		end
		fdda_use_item(obj)
	end

	local fdda_call_my_slot_back = enhanced_animations.call_my_slot_back
	enhanced_animations.call_my_slot_back = function()
		fdda_call_my_slot_back()
		if artefacts.af_star_phantom then
			artefact_props.af_star_phantom.weapon_hidden = true
			db.actor:hide_weapon()
		end
		return true
	end

end

-- Patch for Quick Throw
local quick_throw = actor_effects.Hit_GrenadeQuickthrow
actor_effects.Hit_GrenadeQuickthrow = function()
	if artefacts.af_star_phantom then return end -- Phantom Pacifist perk to prevent quick throwing a grenade
	quick_throw()
end

-- Patch for Quick Melee
if quickdraw and quickdraw.hit_key then
	local quick_melee = quickdraw.hit_key
	quickdraw.hit_key = function()
		if artefacts.af_star_phantom then return end -- Phantom Pacifist perk to prevent quick melee with that mod enabled
		quick_melee()
	end
end

-- Disable talk possibility for Phantom Pacifist
local process_npc_usability = xr_meet.process_npc_usability
xr_meet.process_npc_usability = function(npc)
	if artefacts.af_star_phantom then
		npc:disable_talk()
		return
	end
	process_npc_usability(npc)
end

-- Disable npc evaluation for Phantom Pacifist
local evaluate = xr_meet.evaluator_contact.evaluate
xr_meet.evaluator_contact.evaluate = function(self)
	if artefacts.af_star_phantom then return false end
	return evaluate(self)
end

-- Removing stack effects on refreshing artefacts
local function remove_stack_effects()
	if not artefacts.af_spaika then
		artefact_props.af_spaika:stack_reset()
	end
end

-- Process artefacts
process_artefacts = function(artefacts_table, ...)
	for artefact, props in pairs(artefacts) do
		if artefacts_table[artefact] then
			trace("artefact %s", artefact)
			artefacts_table[artefact](db.actor, props.count, props.ids, props.names, ...)
		end
	end
end

-- Refreshing state
refresh_state = function()
	if refresh_artefacts() then
		remove_speed_boosts()
		remove_stack_effects()
		unregister_callbacks()
		process_artefacts(artefact_on_equip_functions)
	end
end

force_refresh_state = function()
	refresh_artefacts(true)
	remove_speed_boosts()
	remove_stack_effects()
	unregister_callbacks()
	process_artefacts(artefact_on_equip_functions)
	return true
end

local function actor_on_item_use(obj, str)
	trace("actor_on_item_use, item %s", obj:section())

	process_artefacts(artefact_on_item_use_functions, obj)
end

local function actor_on_update()
	tg = floor(time_global() * 0.01)
	--trace("current tg %s", tg)
	if tg < actor_on_update_time then return end
	actor_on_update_time = tg + actor_on_update_timer

	time_elapsed = get_time_elapsed()
	--trace("current time_elapsed %s", time_elapsed)
	process_artefacts(artefact_on_update_functions)
	process_timed_effects()
end

local function actor_on_weapon_fired(obj, wpn, ammo_elapsed, grenade_elapsed, ammo_type, grenade_type)
	trace("weapon fired %s", wpn:section())

	process_artefacts(artefact_on_weapon_fired_functions, obj, wpn, ammo_elapsed, grenade_elapsed, ammo_type, grenade_type)
end

local function actor_on_before_hit(s_hit, bone_id, flags)
	trace("actor_on_before_hit damage type %s", s_hit.type)
	last_hit = hit(s_hit)

	process_artefacts(artefact_on_before_hit_functions, s_hit, bone_id, flags)
end

local function actor_on_hit_callback(obj, amount, local_direction, who, bone_index)
	trace("actor_on_hit_callback, %s, %s, %s", obj:section(), amount, who:section())

	process_artefacts(artefact_on_hit_functions, obj, amount, who, last_hit)
end

local function actor_on_before_death(whoID, flags)
	trace("actor_on_before_death triggered")

	process_artefacts(artefact_on_before_death_functions, whoID, flags)
end

local function actor_on_item_buy(item)
	trace("actor_on_item_buy triggered")

	process_artefacts(artefact_on_trade_functions, item, false)
end

local function actor_on_item_sell(item)
	trace("actor_on_item_sell triggered")

	process_artefacts(artefact_on_trade_functions, item, true)
end

local function npc_on_before_hit(npc, s_hit, bone_id, flags)
	if s_hit.draftsman:id() ~= AC_ID then
		trace("npc_on_before_hit not triggered %s, %s", npc:section(), s_hit.draftsman:section())
		return
	end
	last_npc_hit = hit(s_hit)
	last_npc_hit_bone_index = bone_id

	process_artefacts(artefact_on_npc_before_hit_functions, npc, s_hit, bone_id, flags)
end

local function npc_on_hit_callback(npc, amount, local_direction, who, bone_index)
	if who:id() ~= AC_ID then
		trace("npc_on_hit_callback not triggered %s, %s, %s", npc:section(), amount, who:section())
		return
	end

	--process_artefacts(artefact_on_npc_hit_functions, npc, amount, who, last_npc_hit)
end

local function npc_on_death_callback(npc, who)
	if who:id() ~= AC_ID then
		trace("npc_on_death_callback not triggered %s, %s", npc:section(), who:section())
		return
	end

	process_artefacts(artefact_on_npc_death_functions, npc, who, last_npc_hit, last_npc_hit_bone_index)
end

local function monster_on_before_hit(monster, s_hit, bone_id, flags)
	if s_hit.draftsman:id() ~= AC_ID then
		trace("monster_on_before_hit not triggered %s, %s", monster:section(), s_hit.draftsman:section())
		return
	end

	if not monster:alive() then
		trace("monster_on_before_hit not triggered, monster %s not alive anymore", monster:section())
		return
	end

	last_monster_hit = hit(s_hit)
	last_monster_hit_bone_index = bone_id

	process_artefacts(artefact_on_monster_before_hit_functions, monster, s_hit, bone_id, flags)
end

local function monster_on_death_callback(monster, who)
	if who:id() ~= AC_ID then
		trace("monster_on_death_callback not triggered %s, %s", monster:section(), who:section())
		return
	end

	process_artefacts(artefact_on_monster_death_functions, monster, who, last_monster_hit, last_monster_hit_bone_index)
end

local function actor_on_first_update()
	time_factor = get_time_factor()
	refresh_state()
	local tg_now = time_global()
	local tg_add = (tg_now - tg_lag) * 0.001
	trace("tg_now %s, tg_add %s", tg_now, tg_add)

	for key, effect in pairs(timed_effects) do
		effect.timer = effect.timer + tg_add
	end

	for key, effect in pairs(cooldowns) do
		cooldowns[key] = cooldowns[key] + tg_add
	end

	for key, effect in pairs(status_effects) do
		effect.timer = effect.timer + tg_add
	end

	RegisterScriptCallback("actor_item_to_slot", refresh_state)
	RegisterScriptCallback("actor_item_to_belt", refresh_state)
	RegisterScriptCallback("actor_item_to_ruck", refresh_state)
	RegisterScriptCallback("actor_on_weapon_fired", actor_on_weapon_fired)
	RegisterScriptCallback("actor_on_hit_callback", actor_on_hit_callback)
	RegisterScriptCallback("actor_on_before_hit", actor_on_before_hit)
	RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
	RegisterScriptCallback("actor_on_item_use", actor_on_item_use)
	RegisterScriptCallback("actor_on_update", actor_on_update)
	RegisterScriptCallback("npc_on_before_hit", npc_on_before_hit)
	RegisterScriptCallback("npc_on_hit_callback", npc_on_hit_callback)
	RegisterScriptCallback("npc_on_death_callback", npc_on_death_callback)
	RegisterScriptCallback("monster_on_before_hit", monster_on_before_hit)
	RegisterScriptCallback("monster_on_death_callback", monster_on_death_callback)
end

local function on_trade_started_set_values()
	artefact_props.af_fountain.cashback_triggered = false
	actor_last_money = db.actor:money()
end

local function on_trade_closed_set_values()
	artefact_props.af_fountain.cashback_triggered = false
end

local function ActorMenu_on_trade_started()
	on_trade_started_set_values()
	RegisterScriptCallback("actor_on_item_take", actor_on_item_buy)
	RegisterScriptCallback("actor_on_item_drop", actor_on_item_sell)
end

local function ActorMenu_on_trade_closed()
	on_trade_closed_set_values()
	UnregisterScriptCallback("actor_on_item_take", actor_on_item_buy)
	UnregisterScriptCallback("actor_on_item_drop", actor_on_item_sell)
end

local function save_state(m_data)
	local t = {}
	for key, effect in pairs(timed_effects) do
		if effect.save then
			t[key] = {}
			copy_table(t[key], effect)
			t[key].effect = nil
			t[key].on_end = nil
		end
	end
	m_data.perk_based_artefacts_effects = t
	m_data.perk_based_artefacts_cooldowns = cooldowns
	m_data.perk_based_artefacts_status_effects = status_effects
	m_data.perk_based_artefacts_lucifer_condition = artefact_props.af_lucifer.condition
end

local function load_state(m_data)
	local t = m_data.perk_based_artefacts_effects or {}
	for key, effect in pairs(t) do
		if t[key].effect_function then
			local effect = load(t[key].effect_function)
			t[key].effect = function()
				effect(unpack(t[key].effect_args))
			end
		end
		if t[key].on_end_function then
			local on_end = load(t[key].on_end_function)
			t[key].on_end = function()
				on_end(unpack(t[key].on_end_args))
			end
		end
	end
	timed_effects = t
	cooldowns = m_data.perk_based_artefacts_cooldowns or {}
	status_effects = m_data.perk_based_artefacts_status_effects or {}
	artefact_props.af_lucifer.condition = m_data.perk_based_artefacts_lucifer_condition or 1
end

local function on_option_change()
	if ui_mcm then
		debug_mode = ui_mcm.get("perk_based_artefacts/debug_mode")
	end
end

function on_game_start()
	trace("Registering")
	tg_lag = time_global()
	trace("tg_on_game_start %s", tg_lag)
	RegisterScriptCallback("actor_on_first_update", on_option_change)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	RegisterScriptCallback("load_state", load_state)
	RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("ActorMenu_on_trade_started", ActorMenu_on_trade_started)
	RegisterScriptCallback("ActorMenu_on_trade_closed", ActorMenu_on_trade_closed)
	RegisterScriptCallback("on_option_change", on_option_change)
end
